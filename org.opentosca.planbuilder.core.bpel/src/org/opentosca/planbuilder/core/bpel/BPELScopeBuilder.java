package org.opentosca.planbuilder.core.bpel;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.opentosca.planbuilder.core.bpel.helpers.TOSCAManagementInfrastructureNodeTemplate;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderPlugin;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderPrePhaseDAPlugin;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderPrePhaseIAPlugin;
import org.opentosca.planbuilder.core.plugins.IPlanBuilderProvPhaseOperationPlugin;
import org.opentosca.planbuilder.core.plugins.registry.PluginRegistry;
import org.opentosca.planbuilder.model.tosca.AbstractDeploymentArtifact;
import org.opentosca.planbuilder.model.tosca.AbstractImplementationArtifact;
import org.opentosca.planbuilder.model.tosca.AbstractInterface;
import org.opentosca.planbuilder.model.tosca.AbstractNodeTemplate;
import org.opentosca.planbuilder.model.tosca.AbstractNodeTypeImplementation;
import org.opentosca.planbuilder.model.tosca.AbstractOperation;
import org.opentosca.planbuilder.model.tosca.AbstractRelationshipTemplate;
import org.opentosca.planbuilder.model.tosca.AbstractRelationshipTypeImplementation;
import org.opentosca.planbuilder.model.utils.ModelUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>
 * This Class represents the low-level algorithm for the concept in <a href=
 * "http://www2.informatik.uni-stuttgart.de/cgi-bin/NCSTRL/NCSTRL_view.pl?id=BCLR-0043&mod=0&engl=1&inst=FAK"
 * >Konzept und Implementierung eine Java-Komponente zur Generierung von WS-BPEL
 * 2.0 BuildPlans fuer OpenTOSCA</a>. This includes selecting a implementation
 * (NodeTypeImplementation,Relationship..) where all artifacts (IA, DA) and the
 * operations of the template (Node and Relation) can be used for calling a
 * chain/list/.. of TOSCA operations. All complete possibilities of calls based
 * on the selected Node Type Implementation are hold inside a OperationChain
 * Object. And can be selected to be generated by the determined operations and
 * handling plugins.
 * 
 * </p>
 * Copyright 2017 IAAS University of Stuttgart <br>
 * <br>
 * 
 * @author Kalman Kepes - kepeskn@studi.informatik.uni-stuttgart.de
 * 
 */
public class BPELScopeBuilder {

	final static Logger LOG = LoggerFactory.getLogger(BPELScopeBuilder.class);

	/**
	 * <p>
	 * Filters IA and DA Candidates inside the given ProvisioningChain. Filtering
	 * means if there are IA and DACandidates which don't operate on the same
	 * Template Implementation they are deleted.
	 * </p>
	 * 
	 * @param chain
	 *            a ProvisioningChain to filter
	 */
	private static void filterIncompatibleIADACandidates(OperationChain chain) {
		Map<IANodeTypeImplCandidate, DANodeTypeImplCandidate> compatibleCandidates = new HashMap<IANodeTypeImplCandidate, DANodeTypeImplCandidate>();
		for (IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
			for (DANodeTypeImplCandidate daCandidate : chain.daCandidates) {
				if (iaCandidate.nodeImpl.getName().equals(daCandidate.impl.getName())) {
					compatibleCandidates.put(iaCandidate, daCandidate);
				}
			}
		}
		chain.daCandidates = new ArrayList<DANodeTypeImplCandidate>();
		chain.iaCandidates = new ArrayList<IANodeTypeImplCandidate>();

		for (IANodeTypeImplCandidate key : compatibleCandidates.keySet()) {
			chain.iaCandidates.add(key);
			chain.daCandidates.add(compatibleCandidates.get(key));
		}
	}

	/**
	 * Creates a ProvisioningChain for the given RelationshipTemplate.
	 * 
	 * @param relationshipTemplate
	 *            an AbstractRelationshipTemplate which should be provisioned
	 * @param forSource
	 *            determines whether provisioning is handle on the SourceInterface
	 *            (set to true) or TargetInterface
	 * @return a ProvisioningChain with complete provisioning Candidates
	 */
	public static OperationChain createOperationChain(AbstractRelationshipTemplate relationshipTemplate,
			boolean forSource) {
		// get implementations
		List<AbstractRelationshipTypeImplementation> relationshipTypeImpls = relationshipTemplate.getImplementations();

		if (relationshipTypeImpls.isEmpty()) {
			return null;
		}

		// init chain
		OperationChain chain = new OperationChain(relationshipTemplate);

		// calculate infraNodes
		List<AbstractNodeTemplate> infraNodes = new ArrayList<AbstractNodeTemplate>();

		ModelUtils.getInfrastructureNodes(relationshipTemplate, infraNodes, forSource);

		// check for IA Plugins
		List<IPlanBuilderPrePhaseIAPlugin> iaPlugins = PluginRegistry.getIaPlugins();

		BPELScopeBuilder.calculateBestImplementationRelationIACandidates(relationshipTypeImpls, iaPlugins, infraNodes,
				chain, forSource);

		// check for prov plugins
		List<IPlanBuilderProvPhaseOperationPlugin> provPlugins = PluginRegistry.getProvPlugins();

		BPELScopeBuilder.calculateProvPlugins(chain, provPlugins);

		BPELScopeBuilder.filterIADACandidatesRelations(chain);

		BPELScopeBuilder.reorderProvCandidates(chain);

		return chain;
	}

	/**
	 * Creates a complete ProvisioningChain for the given NodeTemplate
	 * 
	 * @param nodeTemplate
	 *            an AbstractNodeTemplate to create a ProvisioningChain for
	 * @return a complete ProvisioningChain
	 */
	public static OperationChain createOperationCall(AbstractNodeTemplate nodeTemplate, String interfaceName,
			String operationName) {
		// get nodetype implementations
		List<AbstractNodeTypeImplementation> nodeTypeImpls = nodeTemplate.getImplementations();

		if (nodeTypeImpls.isEmpty()) {
			BPELScopeBuilder.LOG.warn(
					"No implementations available for NodeTemplate {} , can't generate Provisioning logic",
					nodeTemplate.getId());
			return null;
		}

		OperationChain chain = new OperationChain(nodeTemplate);

		// calculate infrastructure nodes
		List<AbstractNodeTemplate> infraNodes = new ArrayList<AbstractNodeTemplate>();
		ModelUtils.getInfrastructureNodes(nodeTemplate, infraNodes);

		// we'll add here a dummy infra node, representing the management
		// infrastructure of the tosca engine (WAR IA's implementing tosca
		// operation,..)
		infraNodes.add(new TOSCAManagementInfrastructureNodeTemplate());

		// check for IA Plugins
		List<IPlanBuilderPrePhaseIAPlugin> iaPlugins = PluginRegistry.getIaPlugins();

		BPELScopeBuilder.LOG.debug("Calculating best IA candidates for nodeTemplate {} ", nodeTemplate.getId());
		// calculate nodeImpl candidates where all IAs of each can be
		// provisioned
		BPELScopeBuilder.calculateBestImplementationIACandidates(nodeTypeImpls, iaPlugins, infraNodes, chain,
				interfaceName, operationName);
		for (IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
			int length = iaCandidate.ias.size();
			for (int i = 0; i < length; i++) {
				AbstractImplementationArtifact ia = iaCandidate.ias.get(i);
				AbstractNodeTemplate infraNode = iaCandidate.infraNodes.get(i);
				IPlanBuilderPlugin plugin = iaCandidate.plugins.get(i);
				BPELScopeBuilder.LOG.debug("Found IA {} for deployment on the InfraNode {} with the Plugin {}",
						ia.getName(), infraNode.getId(), plugin.getID());
			}
		}

		// check for prov plugins
		List<IPlanBuilderProvPhaseOperationPlugin> provPlugins = PluginRegistry.getProvPlugins();

		// search for prov plugins according to the chosen IA provisionings in
		// the chain
		BPELScopeBuilder.calculateProvPlugins(chain, provPlugins, interfaceName, operationName);

		// filter ia and da candidates where the operations can't be executed
		BPELScopeBuilder.filterIADACandidates(chain);

		// order provisioning candidates
		BPELScopeBuilder.reorderProvCandidates(chain);

		// TODO consistency plugins

		// select provisioning
		BPELScopeBuilder.selectProvisioning(chain);

		return chain;
	}

	/**
	 * Creates a complete ProvisioningChain for the given NodeTemplate
	 * 
	 * @param nodeTemplate
	 *            an AbstractNodeTemplate to create a ProvisioningChain for
	 * @return a complete ProvisioningChain
	 */
	public static OperationChain createOperationChain(AbstractNodeTemplate nodeTemplate) {
		// get nodetype implementations
		List<AbstractNodeTypeImplementation> nodeTypeImpls = nodeTemplate.getImplementations();

		if (nodeTypeImpls.isEmpty()) {
			BPELScopeBuilder.LOG.warn(
					"No implementations available for NodeTemplate {} , can't generate Provisioning logic",
					nodeTemplate.getId());
			return null;
		}

		OperationChain chain = new OperationChain(nodeTemplate);

		// calculate infrastructure nodes
		List<AbstractNodeTemplate> infraNodes = new ArrayList<AbstractNodeTemplate>();
		ModelUtils.getInfrastructureNodes(nodeTemplate, infraNodes);

		// we'll add here a dummy infra node, representing the management
		// infrastructure of the tosca engine (WAR IA's implementing tosca
		// operation,..)
		infraNodes.add(new TOSCAManagementInfrastructureNodeTemplate());

		// check for IA Plugins
		List<IPlanBuilderPrePhaseIAPlugin> iaPlugins = PluginRegistry.getIaPlugins();

		BPELScopeBuilder.LOG.debug("Calculating best IA candidates for nodeTemplate {} ", nodeTemplate.getId());
		// calculate nodeImpl candidates where all IAs of each can be
		// provisioned
		BPELScopeBuilder.calculateBestImplementationIACandidates(nodeTypeImpls, iaPlugins, infraNodes, chain);
		for (IANodeTypeImplCandidate wrapper : chain.iaCandidates) {
			int length = wrapper.ias.size();
			for (int i = 0; i < length; i++) {
				AbstractImplementationArtifact ia = wrapper.ias.get(i);
				AbstractNodeTemplate infraNode = wrapper.infraNodes.get(i);
				IPlanBuilderPlugin plugin = wrapper.plugins.get(i);
				BPELScopeBuilder.LOG.debug("Found IA {} for deployment on the InfraNode {} with the Plugin {}",
						ia.getName(), infraNode.getId(), plugin.getID());
			}
		}

		// check for DA Plugins
		List<IPlanBuilderPrePhaseDAPlugin> daPlugins = PluginRegistry.getDaPlugins();

		// calculate nodeImpl candidates where all DAs of each can be
		// provisioned
		BPELScopeBuilder.calculateBestImplementationDACandidates(nodeTemplate, nodeTypeImpls, daPlugins, infraNodes,
				chain);
		for (DANodeTypeImplCandidate wrapper : chain.daCandidates) {
			int length = wrapper.das.size();
			for (int i = 0; i < length; i++) {
				AbstractDeploymentArtifact da = wrapper.das.get(i);
				AbstractNodeTemplate infraNode = wrapper.infraNodes.get(i);
				IPlanBuilderPlugin plugin = wrapper.plugins.get(i);
				BPELScopeBuilder.LOG.debug("Found DA {} for deployment on the InfraNode {} with the Plugin {}",
						da.getName(), infraNode.getId(), plugin.getID());
			}
		}

		// filter for nodeTypeImpl Candidates where both DAs and IAs can
		// be provisioned
		BPELScopeBuilder.filterIncompatibleIADACandidates(chain);

		// check for prov plugins
		List<IPlanBuilderProvPhaseOperationPlugin> provPlugins = PluginRegistry.getProvPlugins();

		// search for prov plugins according to the chosen IA provisionings in
		// the chain
		BPELScopeBuilder.calculateProvPlugins(chain, provPlugins);

		// filter ia and da candidates where the operations can't be executed
		BPELScopeBuilder.filterIADACandidates(chain);

		// order provisioning candidates
		BPELScopeBuilder.reorderProvCandidates(chain);

		// TODO consistency plugins

		// select provisioning
		BPELScopeBuilder.selectProvisioning(chain);

		return chain;
	}

	/**
	 * Reorders the IA/ProvCandidates inside the given ProvisioningChain, so that a
	 * correct order is enforced
	 * 
	 * @param chain
	 *            a ProvisioningChain
	 */
	private static void reorderProvCandidates(OperationChain chain) {
		// ia candidates and da candidates in the chains are already ordered
		// accordingly
		List<OperationNodeTypeImplCandidate> reorderedList = new ArrayList<OperationNodeTypeImplCandidate>();
		for (IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
			int iaCandidateSize = iaCandidate.ias.size();
			for (OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
				int count = 0;
				for (AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
					for (AbstractImplementationArtifact provCandidateIa : provCandidate.ias) {
						if (iaCandidateIa.equals(provCandidateIa)) {
							count++;
						}
					}
				}
				if (count == iaCandidateSize) {
					reorderedList.add(provCandidate);
				}
			}
		}

		chain.provCandidates = reorderedList;

	}

	/**
	 * Filters IA and ProvCandidates which aren't generated from the same Template
	 * Implementation
	 * 
	 * @param chain
	 *            a ProvisioningChain
	 */
	private static void filterIADACandidatesRelations(OperationChain chain) {
		if (chain.provCandidates.size() != chain.iaCandidates.size()) {
			List<IANodeTypeImplCandidate> iaCandidatesToRemove = new ArrayList<IANodeTypeImplCandidate>();
			Set<OperationNodeTypeImplCandidate> provCandidatesWithMatch = new HashSet<OperationNodeTypeImplCandidate>();
			for (IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
				int iaCandidateSize = iaCandidate.ias.size();
				OperationNodeTypeImplCandidate match = null;
				for (OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
					int count = 0;
					for (AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
						for (AbstractImplementationArtifact procCandidateIa : provCandidate.ias) {
							if (iaCandidateIa.equals(procCandidateIa)) {
								count++;
							}
						}
					}
					if (count == iaCandidateSize) {
						match = provCandidate;
					}
				}
				if ((match == null) && !chain.provCandidates.isEmpty()) {
					iaCandidatesToRemove.add(iaCandidate);
				} else {
					if (match != null) {
						provCandidatesWithMatch.add(match);
					}
				}
			}
			if (!iaCandidatesToRemove.isEmpty()) {
				// we need to remove ia and da candidates accordingly, because
				// we didn't found matchin operation candidates for them
				for (IANodeTypeImplCandidate iaCandidateToRemove : iaCandidatesToRemove) {
					int index = chain.iaCandidates.indexOf(iaCandidateToRemove);
					chain.iaCandidates.remove(index);
				}
			}

			if (!provCandidatesWithMatch.isEmpty()) {
				// remove all prov candidates which weren't matched to some ia
				// candidate
				chain.provCandidates = new ArrayList<OperationNodeTypeImplCandidate>();
				for (OperationNodeTypeImplCandidate matchedCandidate : provCandidatesWithMatch) {
					chain.provCandidates.add(matchedCandidate);
				}
			}
		}
	}

	/**
	 * Filters DA/IA Candidates where no OperationCandidates could be found
	 * 
	 * @param chain
	 *            a ProvisioningChain
	 */
	private static void filterIADACandidates(OperationChain chain) {
		if (chain.provCandidates.size() != chain.iaCandidates.size()) {
			// search for ia/da-Candidates where no operation candidate could be
			// found
			List<IANodeTypeImplCandidate> iaCandidatesToRemove = new ArrayList<IANodeTypeImplCandidate>();
			Set<OperationNodeTypeImplCandidate> provCandidatesWithMatch = new HashSet<OperationNodeTypeImplCandidate>();
			for (IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
				int iaCandidateSize = iaCandidate.ias.size();
				OperationNodeTypeImplCandidate match = null;
				for (OperationNodeTypeImplCandidate provCandidate : chain.provCandidates) {
					int count = 0;
					for (AbstractImplementationArtifact iaCandidateIa : iaCandidate.ias) {
						for (AbstractImplementationArtifact provCandidateIa : provCandidate.ias) {
							if (iaCandidateIa.equals(provCandidateIa)) {
								count++;
							}
						}
					}
					if (count == iaCandidateSize) {
						match = provCandidate;
					}
				}
				if ((match == null) && !chain.provCandidates.isEmpty()) {
					iaCandidatesToRemove.add(iaCandidate);
				} else {
					if (match != null) {
						provCandidatesWithMatch.add(match);
					}
				}
			}

			if (!iaCandidatesToRemove.isEmpty()) {
				// we need to remove ia and da candidates accordingly, because
				// we didn't found matchin operation candidates for them
				for (IANodeTypeImplCandidate iaCandidateToRemove : iaCandidatesToRemove) {
					int index = chain.iaCandidates.indexOf(iaCandidateToRemove);
					chain.iaCandidates.remove(index);
					chain.daCandidates.remove(index);
				}
			}

			if (!provCandidatesWithMatch.isEmpty()) {
				// remove all prov candidates which weren't matched to some ia
				// candidate
				chain.provCandidates = new ArrayList<OperationNodeTypeImplCandidate>();
				for (OperationNodeTypeImplCandidate matchedCandidate : provCandidatesWithMatch) {
					chain.provCandidates.add(matchedCandidate);
				}
			}
		}
	}

	private static void selectProvisioning(OperationChain chain) {
		// TODO just select the first ia candidate, da candidate and prov
		// candidate for now
		// Selection should determine a minimal provisioning. Minimal=
		// min{|IACandidates| + |DACandidates| +|ProvPhaseOperations|}
	}

	/**
	 * Calculates which Provisioning can be used for Provisioining according to the
	 * given IA/DACandidates inside the given ProvisioningChain
	 * 
	 * @param chain
	 *            a ProvisioningChain with set DA/IACandidates
	 * @param provPlugins
	 *            a List of ProvPhaseOperationPlugins
	 */
	private static void calculateProvPlugins(OperationChain chain,
			List<IPlanBuilderProvPhaseOperationPlugin> provPlugins, String interfaceName, String operationName) {
		List<OperationNodeTypeImplCandidate> candidates = new ArrayList<OperationNodeTypeImplCandidate>();
		for (IANodeTypeImplCandidate iaCandidate : chain.iaCandidates) {
			OperationNodeTypeImplCandidate provCandidate = new OperationNodeTypeImplCandidate();
			for (AbstractImplementationArtifact ia : iaCandidate.ias) {
				if (!ia.getInterfaceName().trim().equals(interfaceName.trim())) {
					continue;
				}
				if (ia.getOperationName() != null && !ia.getOperationName().trim().equals(operationName.trim())) {
					continue;
				}
				for (IPlanBuilderProvPhaseOperationPlugin plugin : provPlugins) {
					if (chain.nodeTemplate != null) {
						if (plugin.canHandle(ia.getArtifactType())
								&& (BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia) != null)) {

							provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia), ia, plugin);
						}
					} else {
						if (plugin.canHandle(ia.getArtifactType())
								&& (BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia) != null)) {
							provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia), ia,
									plugin);
						}
					}
				}
			}
			if (chain.nodeTemplate != null) {
				if (provCandidate.isValid(chain.nodeTemplate, interfaceName, operationName)) {
					candidates.add(provCandidate);
				}
			} else {
				if (provCandidate.isValid(chain.relationshipTemplate)) {
					candidates.add(provCandidate);
				}
			}

		}
		chain.provCandidates = candidates;
	}

	/**
	 * Calculates which Provisioning can be used for Provisioining according to the
	 * given IA/DACandidates inside the given ProvisioningChain
	 * 
	 * @param chain
	 *            a ProvisioningChain with set DA/IACandidates
	 * @param provPlugins
	 *            a List of ProvPhaseOperationPlugins
	 */
	private static void calculateProvPlugins(OperationChain chain,
			List<IPlanBuilderProvPhaseOperationPlugin> provPlugins) {
		List<OperationNodeTypeImplCandidate> candidates = new ArrayList<OperationNodeTypeImplCandidate>();
		for (IANodeTypeImplCandidate candidate : chain.iaCandidates) {
			OperationNodeTypeImplCandidate provCandidate = new OperationNodeTypeImplCandidate();
			for (AbstractImplementationArtifact ia : candidate.ias) {
				for (IPlanBuilderProvPhaseOperationPlugin plugin : provPlugins) {
					if (chain.nodeTemplate != null) {
						if (plugin.canHandle(ia.getArtifactType())
								&& (BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia) != null)) {

							provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.nodeTemplate, ia), ia, plugin);
						}
					} else {
						if (plugin.canHandle(ia.getArtifactType())
								&& (BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia) != null)) {
							provCandidate.add(BPELScopeBuilder.getOperationForIa(chain.relationshipTemplate, ia), ia,
									plugin);
						}
					}
				}
			}
			if (chain.nodeTemplate != null) {
				if (provCandidate.isValid(chain.nodeTemplate)) {
					candidates.add(provCandidate);
				}
			} else {
				if (provCandidate.isValid(chain.relationshipTemplate)) {
					candidates.add(provCandidate);
				}
			}

		}
		chain.provCandidates = candidates;
	}

	/**
	 * Returns the Operation which is implemented by the given IA
	 * 
	 * @param nodeTemplate
	 *            an AbstractNodeTemplate
	 * @param ia
	 *            an AbstractImplementationArtifact
	 * @return AbstractOperation of the NodeTemplate if the given IA implements it,
	 *         else null
	 */
	private static AbstractOperation getOperationForIa(AbstractNodeTemplate nodeTemplate,
			AbstractImplementationArtifact ia) {

		if (ia.getInterfaceName() != null & ia.getOperationName() == null) {
			return new InterfaceDummy(nodeTemplate, ia);
		}

		for (AbstractInterface iface : nodeTemplate.getType().getInterfaces()) {
			for (AbstractOperation op : iface.getOperations()) {
				if (op.getName().equals(ia.getOperationName())) {
					return op;
				}
			}
		}
		return null;
	}

	/**
	 * Returns the Operation which is implemented by the given IA
	 * 
	 * @param relationshipTemplate
	 *            an AbstractRelationshipTemplate
	 * @param ia
	 *            an AbstractImplementationArtifact
	 * @return AbstractOperation of the RelationshipTemplate if the given IA
	 *         implements it, else null
	 */
	private static AbstractOperation getOperationForIa(AbstractRelationshipTemplate relationshipTemplate,
			AbstractImplementationArtifact ia) {
		for (AbstractInterface iface : relationshipTemplate.getRelationshipType().getSourceInterfaces()) {
			for (AbstractOperation op : iface.getOperations()) {
				if (op.getName().equals(ia.getOperationName())) {
					return op;
				}
			}
		}

		for (AbstractInterface iface : relationshipTemplate.getRelationshipType().getTargetInterfaces()) {
			for (AbstractOperation op : iface.getOperations()) {
				if (op.getName().equals(ia.getOperationName())) {
					return op;
				}
			}
		}
		return null;
	}

	/**
	 * Calculates correct mappings of the given NodeTypeImplementations,
	 * PrePhaseDAPlugins and InfrastructureNodes for the given ProvisioningChain
	 * 
	 * @param impls
	 *            a List of NodeTypeImplementations
	 * @param plugins
	 *            a List of PrePhaseDAPlugins
	 * @param infraNodes
	 *            a List of InfrastructureNode of the NodeTemplate the
	 *            NodeTypeImplementations belong to
	 * @param chain
	 *            a ProvisioningChain where the candidates are added to
	 */
	private static void calculateBestImplementationDACandidates(AbstractNodeTemplate nodeTemplate,
			List<AbstractNodeTypeImplementation> impls, List<IPlanBuilderPrePhaseDAPlugin> plugins,
			List<AbstractNodeTemplate> infraNodes, OperationChain chain) {
		List<DANodeTypeImplCandidate> candidates = new ArrayList<DANodeTypeImplCandidate>();

		for (AbstractNodeTypeImplementation impl : impls) {
			BPELScopeBuilder.LOG.debug("Checking DAs of NodeTypeImpl {} and NodeTemplate {}", impl.getName(),
					nodeTemplate.getId());
			DANodeTypeImplCandidate candidate = new DANodeTypeImplCandidate(nodeTemplate, impl);

			List<AbstractDeploymentArtifact> effectiveDAs = BPELScopeBuilder.calculateEffectiveDAs(nodeTemplate, impl);

			for (AbstractDeploymentArtifact da : effectiveDAs) {
				BPELScopeBuilder.LOG.debug("Checking whether DA {} can be deployed", da.getName());
				for (AbstractNodeTemplate infraNode : infraNodes) {
					BPELScopeBuilder.LOG.debug("Checking if DA {} can be deployed on InfraNode {}", da.getName(),
							infraNode.getId());
					for (IPlanBuilderPrePhaseDAPlugin plugin : plugins) {
						BPELScopeBuilder.LOG.debug("Checking with Plugin {}", plugin.getID());
						if (plugin.canHandle(da, infraNode.getType())) {
							BPELScopeBuilder.LOG.debug("Adding Plugin, can handle DA on InfraNode");
							candidate.add(da, infraNode, plugin);
						}
					}
				}
			}
			if (candidate.isValid()) {
				BPELScopeBuilder.LOG.debug("Generated Candidate was valid, adding to all Candidates");
				candidates.add(candidate);
			} else {
				BPELScopeBuilder.LOG.debug("Generated Candidate was invalid, don't add to all Candidates");
			}
		}
		chain.daCandidates = candidates;
	}

	/**
	 * Searches for NodeTypeImplementations where all IA's can be provisioned by
	 * some plugin in the system.
	 * 
	 * @param impls
	 *            all implementations of single nodetype
	 * @param plugins
	 *            all plugins possibly capable of working with the ia's contained in
	 *            a nodetypeImplementation
	 * @param infraNodes
	 *            all infrastructure nodes of the nodetemplate the
	 *            nodetypeimplementations originate from
	 * @return a list of Wrapper class Object which contain information of which ia
	 *         is provisioned on which infrastructure by which plugin
	 */
	private static void calculateBestImplementationIACandidates(List<AbstractNodeTypeImplementation> impls,
			List<IPlanBuilderPrePhaseIAPlugin> plugins, List<AbstractNodeTemplate> infraNodes, OperationChain chain,
			String interfaceName, String operationName) {

		List<IANodeTypeImplCandidate> candidates = new ArrayList<IANodeTypeImplCandidate>();
		// cycle through all implementations
		for (AbstractNodeTypeImplementation impl : impls) {
			IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
			// match the ias of the implementation with the infrastructure nodes
			for (AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
				if (!ia.getInterfaceName().trim().equals(interfaceName.trim())) {
					continue;
				}
				if (ia.getOperationName() != null && !ia.getOperationName().trim().equals(operationName.trim())) {
					continue;
				}

				BPELScopeBuilder.LOG.debug("Checking whether IA {} can be deployed on a specific Infrastructure Node",
						ia.getName());
				for (AbstractNodeTemplate infraNode : infraNodes) {
					// check if any plugin can handle installing the ia on the
					// infraNode
					for (IPlanBuilderPrePhaseIAPlugin plugin : plugins) {
						if (plugin.canHandle(ia, infraNode.getType())) {
							candidate.add(ia, infraNode, plugin);
						}
					}
				}
			}
			// check if all ias of the implementation can be provisioned
			if (candidate.isValid(interfaceName, operationName)) {
				candidates.add(candidate);
				BPELScopeBuilder.LOG.debug("IA Candidate is valid, adding to candidate list");
			} else {
				BPELScopeBuilder.LOG.debug("IA Candidate is invalid, discarding candidate");
			}
		}
		chain.iaCandidates = candidates;
	}

	/**
	 * Searches for NodeTypeImplementations where all IA's can be provisioned by
	 * some plugin in the system.
	 * 
	 * @param impls
	 *            all implementations of single nodetype
	 * @param plugins
	 *            all plugins possibly capable of working with the ia's contained in
	 *            a nodetypeImplementation
	 * @param infraNodes
	 *            all infrastructure nodes of the nodetemplate the
	 *            nodetypeimplementations originate from
	 * @return a list of Wrapper class Object which contain information of which ia
	 *         is provisioned on which infrastructure by which plugin
	 */
	private static void calculateBestImplementationIACandidates(List<AbstractNodeTypeImplementation> impls,
			List<IPlanBuilderPrePhaseIAPlugin> plugins, List<AbstractNodeTemplate> infraNodes, OperationChain chain) {

		List<IANodeTypeImplCandidate> candidates = new ArrayList<IANodeTypeImplCandidate>();
		// cycle through all implementations
		for (AbstractNodeTypeImplementation impl : impls) {
			IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
			// match the ias of the implementation with the infrastructure nodes
			for (AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
				BPELScopeBuilder.LOG.debug("Checking whether IA {} can be deployed on a specific Infrastructure Node",
						ia.getName());
				for (AbstractNodeTemplate infraNode : infraNodes) {
					// check if any plugin can handle installing the ia on the
					// infraNode
					for (IPlanBuilderPrePhaseIAPlugin plugin : plugins) {
						if (plugin.canHandle(ia, infraNode.getType())) {
							candidate.add(ia, infraNode, plugin);
						}
					}
				}
			}
			// check if all ias of the implementation can be provisioned
			if (candidate.isValid()) {
				candidates.add(candidate);
				BPELScopeBuilder.LOG.debug("IA Candidate is valid, adding to candidate list");
			} else {
				BPELScopeBuilder.LOG.debug("IA Candidate is invalid, discarding candidate");
			}
		}
		chain.iaCandidates = candidates;
	}

	/**
	 * Checks whether the IA implements a SourceInterfaceOperation
	 * 
	 * @param ia
	 *            the IA to check with
	 * @param relationshipTemplate
	 *            the RelationshipTemplate to check with
	 * @return true if the IA implements a Operation inside a SourceInterface of the
	 *         RelationshipTemplate
	 */
	private static boolean checkIfIaImplementsSrcIface(AbstractImplementationArtifact ia,
			AbstractRelationshipTemplate relationshipTemplate) {

		for (AbstractInterface iface : relationshipTemplate.getRelationshipType().getSourceInterfaces()) {
			if (iface.getName().equals(ia.getInterfaceName())) {
				for (AbstractOperation op : iface.getOperations()) {
					if (op.getName().equals(ia.getOperationName())) {
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * Calculates correct mappings for the given RelationshipTypeImplementations
	 * with the given Plugins and InfraNodes
	 * 
	 * @param impls
	 *            a List of RelationshipTypeImplementation
	 * @param plugins
	 *            a List of PrePhaseIAPlugins
	 * @param infraNodes
	 *            a List of InfrastructureNodes which belong to the
	 *            RelationshipTemplate the given Implementation belong to
	 * @param chain
	 *            a ProvisioningChain to save the results
	 * @param forSource
	 *            whether the calculation is done for the SourceInterface or for the
	 *            TargetInterface
	 */
	private static void calculateBestImplementationRelationIACandidates(
			List<AbstractRelationshipTypeImplementation> impls, List<IPlanBuilderPrePhaseIAPlugin> plugins,
			List<AbstractNodeTemplate> infraNodes, OperationChain chain, boolean forSource) {
		List<IANodeTypeImplCandidate> candidates = new ArrayList<IANodeTypeImplCandidate>();
		for (AbstractRelationshipTypeImplementation impl : impls) {
			IANodeTypeImplCandidate candidate = new IANodeTypeImplCandidate(impl);
			for (AbstractImplementationArtifact ia : impl.getImplementationArtifacts()) {
				if (forSource) {
					// check if ia implements source interfaces
					if (!BPELScopeBuilder.checkIfIaImplementsSrcIface(ia, chain.relationshipTemplate)) {
						continue;
					}
				} else {
					if (BPELScopeBuilder.checkIfIaImplementsSrcIface(ia, chain.relationshipTemplate)) {
						continue;
					}
				}

				for (AbstractNodeTemplate infraNode : infraNodes) {
					for (IPlanBuilderPrePhaseIAPlugin plugin : plugins) {
						if (plugin.canHandle(ia, infraNode.getType())) {
							candidate.add(ia, infraNode, plugin);
						}
					}
				}
			}
			if (candidate.isValid()) {
				candidates.add(candidate);
			}
		}
		chain.iaCandidates = candidates;

	}

	/**
	 * Calculates a list of DA's containing an effective set of DA combining the
	 * DA's from the given NodeImplementation and NodeTemplates according to the
	 * TOSCA specification.
	 * 
	 * @param nodeTemplate
	 *            the NodeTemplate the NodeImplementations belongs to
	 * @param nodeImpl
	 *            a NodeTypeImplementation for the given NodeTemplate
	 * @return a possibly empty list of AbstractDeploymentArtifacts
	 */
	static List<AbstractDeploymentArtifact> calculateEffectiveDAs(AbstractNodeTemplate nodeTemplate,
			AbstractNodeTypeImplementation nodeImpl) {
		List<AbstractDeploymentArtifact> effectiveDAs = new ArrayList<AbstractDeploymentArtifact>();

		List<AbstractDeploymentArtifact> nodeImplDAs = nodeImpl.getDeploymentArtifacts();
		List<AbstractDeploymentArtifact> nodeTemplateDAs = nodeTemplate.getDeploymentArtifacts();

		for (AbstractDeploymentArtifact templateDa : nodeTemplateDAs) {
			boolean overridesDA = false;
			int daIndex = -1;
			for (int i = 0; i < nodeImplDAs.size(); i++) {
				AbstractDeploymentArtifact nodeImplDa = nodeImplDAs.get(i);

				if (nodeImplDa.getName().equals(templateDa.getName())
						& nodeImplDa.getArtifactType().equals(nodeImplDa.getArtifactType())) {
					overridesDA = true;
					daIndex = i;
				}
			}

			if (overridesDA) {
				nodeImplDAs.remove(daIndex);
			}
		}

		effectiveDAs.addAll(nodeTemplateDAs);
		effectiveDAs.addAll(nodeImplDAs);

		return effectiveDAs;
	}
}
